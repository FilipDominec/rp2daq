# RP2DAQ: Python API reference

This file was auto-generated by c_code_parser.py, using comments found in all ```include/*.c``` source files.

 Contents:

   1. [identify](#identify)
   1. [gpio_out](#gpio_out)
   1. [gpio_in](#gpio_in)
   1. [gpio_on_change](#gpio_on_change)
   1. [adc](#adc)
   1. [pwm_configure_pair](#pwm_configure_pair)
   1. [pwm_set_value](#pwm_set_value)
   1. [stepper_init](#stepper_init)
   1. [stepper_status](#stepper_status)
   1. [stepper_move](#stepper_move)
   1. [gpio_pull](#gpio_pull)
   1. [gpio_highz](#gpio_highz)
   1. [adc_stop](#adc_stop)


## identify

Mostly for internal use: confirms the RP2DAQ device is up and has matching firmware version

__This command results in single near-immediate report.__

__Call signature:__

`identify(flush_buffer=1,  _callback=None)`

__Parameters__:

  * flush_buffer : Avoid possible pending messages from previous session 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## gpio_out

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 
Depending on the "value=0" or "value=1" parameter, it connects the pin directly to 0 V,
or 3.3 V, respectively.  

This overrides previous high-impedance or pull-up/down state of the pin. 

__This command results in single, meaningless, near-immediate report.__

__Call signature:__

`gpio_out(gpio, value,  _callback=None)`

__Parameters__:

  * gpio : The number of the gpio to be configured 
  * value : Output value (i.e. 0 or 3.3 V) for high_z 0 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## gpio_in

Returns the digital state of a gpio pin. 

Typically used when the pin is set to high-z or pull-up/down.

__This command results in single near-immediate report.__

__Call signature:__

`gpio_in(gpio,  _callback=None)`

__Parameters__:

  * gpio   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## gpio_on_change

Sets up a gpio to issue a report every time the gpio changes its state. This is sensitive to both external and internal events.

__Fixme__: in current firmware, edge events cannot be turned off! 

__This command potentially results in multiple later reports. Note that input signal over 10kHz may result in some events not being reported.__

__Call signature:__

`gpio_on_change(gpio, on_rising_edge=1, on_falling_edge=1,  _callback=None)`

__Parameters__:

  * gpio : gpio specification 
  * on_rising_edge : Reports on gpio going from logical 0 to 1 
  * on_falling_edge : Reports on gpio going from logical 1 to 0 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## adc

Initiates analog-to-digital conversion (ADC), using the RP2040 built-in feature.

When ADC is already active, this takes no action. Use adc_stop() first in such a case.  

__This command can result in one, several or infinitely many report(s). They can be 
almost immediate or delayed, depending on block size and timing.__

__Call signature:__

`adc(channel_mask=1, blocksize=1000, infinite=0, blocks_to_send=1, clkdiv=96, trigger_gpio=-1, trigger_on_falling_edge=0,  _callback=None)`

__Parameters__:

  * channel_mask : Masks 0x01, 0x02, 0x04 are GPIO26, 27, 28; mask 0x08 internal reference, 0x10 temperature sensor 
  * blocksize : Number of sample points until a report is sent 
  * infinite : Disables blocks_to_send countdown; reports will keep coming until stopped by adc(blocks_to_send=0) 
  * blocks_to_send : Limits the number of reports to be sent (if the 'infinite' option is not set) 
  * clkdiv : Sampling rate is 48MHz/clkdiv (e.g. 96 gives 500 ksps; 48000 gives 1000 sps etc.) 
  * trigger_gpio : GPIO number for start trigger (leave -1 to make ADC start immediately) 
  * trigger_on_falling_edge : If set to 1, triggers on falling edge instead of rising edge. 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## pwm_configure_pair

Sets frequency for a "PWM slice", i.e. pair of GPIOs 

To control usual small servos, set `wrap_value=65535, clkdiv=20` to get 190 Hz
cycle. Value of 10000 (0.8ms pulse) then turns servo near its minimum value,
and value of 30000 (2.4ms pulse) turns it near maximum value. YMMV.
(see https://en.wikipedia.org/wiki/Servo_control)

When PWM is low-pass filtered to generate analog signal (like a poor man's DAC),
clkdiv=1 will yield best results; the wrap value can be reduced to get 
faster cycle, thus more efficient filtering & better time resolution.

Note while almost all GPIOs can be enabled for PWM output, there are
only 16 channels (e.g. GPIOs 0, 16 will have the same value, if PWM output 
enabled), and there are only 8 slices (e.g. GPIOs 0, 1, 16 and 17 share 
also the same clkdiv, wrap and clkdiv_int_frac values.)

__This command results in one near-immediate report.__

__Call signature:__

`pwm_configure_pair(gpio=0, wrap_value=999, clkdiv=1, clkdiv_int_frac=0,  _callback=None)`

__Parameters__:

  * gpio   
  * wrap_value   
  * clkdiv   
  * clkdiv_int_frac   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## pwm_set_value

Quickly sets duty cycle for one GPIO

It is assumed this GPIO already was configured by `pwm_configure_pair()`.

__This command results in one near-immediate report.__

__Call signature:__

`pwm_set_value(gpio=0, value=0,  _callback=None)`

__Parameters__:

  * gpio   
  * value   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## stepper_init

Rp2daq allows to control up to 16 independent stepper motors, provided that
each motor has its current driver compatible with Stepstick A4988. For this
driver rp2daq generates two control signals - "dir" and "step" - determining 
the direction and speed of rotation, respectively. The GPIO numbers of these
signals are mandatory parameters.

Optionally one can provide the "disable" GPIO number which, when connected to 
the "!enable" pin on A4988 will automatically turn off current to save energy.

Independent of the A4988, rp2daq accepts the "endswitch" GPIO which 
automatically stops the stepper whenever it reaches the minimum or maximum 
position. Having a dedicated end stop is both safety and convenience measure, 
allowing one to easily calibrate the stepper position upon restart. 

The "inertia" parameter allows for smooth ac-/de-celeration of the stepper, 
preventing it from losing steps at startup even at high rotation speeds. The 
default value is usually OK unless the stepper moves some heavy mass.

This command only defines constants and initializes GPIO states, but does not 
move the stepper; for this one uses the stepper_move() command.

__Call signature:__

`stepper_init(stepper_number, dir_gpio, step_gpio, endswitch_gpio=-1, disable_gpio=-1, inertia=30,  _callback=None)`

__Parameters__:

  * stepper_number   
  * dir_gpio   
  * step_gpio   
  * endswitch_gpio   
  * disable_gpio   
  * inertia   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## stepper_status

Returns the position and endswitch status of the stepper selected by "stepper_number".

Additionally, returns three 16-bit integers (bitmasks) for all indices 0..15, 
describing if each corresponding stepper was initialized, if it is actively moving and 
if it is currently at endswitch. 

These bitmasks are particularly useful when multiple steppers are to be synchronized, 
e.g., into a two-dimensional movement. (New set of stepper_move() commands then would 
be issued only when all relevant bits in steppers_moving_bitmask are cleared.)

__Results in one immediate report.__

__Call signature:__

`stepper_status(stepper_number,  _callback=None)`

__Parameters__:

  * stepper_number   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## stepper_move

Starts stepping motor movement from current position towards the new position given by "to". The 
motor has to be initialized by stepper_init first (please refer to this command for more details on 
stepper control). 

The units of position are nanosteps, i.e., 1/256 of a microstep. So typically if you have a motor
with 1.8 degree/step and your A4988-compatible driver uses 16 microsteps/step, it takes 
360/1.8*256*16 = 819200 nanosteps per turn.

The "speed" is in nanosteps per 0.1 ms update cycle; thus setting the speed to 82 turns the motor in 
the above example once in second. Note most stepper motors won't turn much faster than 600 RPM.

When no callback is provided, this command blocks your program until the movement is finished. 
Using asychronous commands one can easily make multiple steppers move at once.

The initial and terminal part of the movement are smoothly ac-/de-celerated, however issuing
this command to an already moving stepper results in its immediate stopping before it starts 
moving smoothly again.

__This command results one report after the movement is finished. Thus it may be immediate 
or delayed by seconds, minutes or hours, depending on distance and speed. __

__Call signature:__

`stepper_move(stepper_number, to, speed, endswitch_ignore=-1, endswitch_expect=-1, reset_nanopos=0,  _callback=None)`

__Parameters__:

  * stepper_number   
  * to   
  * speed   
  * endswitch_ignore   
  * endswitch_expect   
  * reset_nanopos   
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## gpio_pull

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 

Depending on the "pull=0" or "pull=1" parameter, it engages one of the built-in cca. 
50 kOhm resistors to pull the pin towards 0 or 3.3 V, respectively.  

This overrides previous direct-output or high-impedance state of the pin. 

__This command results in single, meaningless, near-immediate report.__

__Call signature:__

`gpio_pull(gpio, value,  _callback=None)`

__Parameters__:

  * gpio : The number of the gpio to be configured 
  * value : Output value (i.e. 0 or 3.3 V) for high_z 0 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## gpio_highz

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 

The pin will become "high-impedance", or "floating", disconnected from any voltage 
supply or drain.

This overrides previous direct-output or pull-up/down state of the pin. 

__This command results in single, meaningless, near-immediate report.__

__Call signature:__

`gpio_highz(gpio,  _callback=None)`

__Parameters__:

  * gpio : The number of the gpio to be configured 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 




## adc_stop

Manually sets the analog-to-digital conversion not to start another ADC block after the active block is 
finished. This means that later onwards, one or more ADC report(s) may still arrive if they were active 
ADC and/or USB buffer. But if an ADC block was waited for a trigger to start, it won't be started.

Adc_stop() is most useful when adc(infinite=True) was previously called. If you know the number of blocks
you will need, it is advisable to call adc(blocks_to_send=X) instead.

If ADC is not running, this takes no action. 

__This command will result in one immediate report.  __

__Call signature:__

`adc_stop(finish_last_adc_packet=1,  _callback=None)`

__Parameters__:

  * finish_last_adc_packet : Hard stopping of ADC in the middle of a block not implemented yet. 
  * _callback: optional report handling function; if set, makes this command asynchronous so it does not wait for report 


