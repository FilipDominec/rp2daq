# RP2DAQ: Python API reference

This file was auto-generated by c_code_parser.py, using comments found in all ```include/*.c``` source files.

 Contents:

   1. [identify](#identify)
   1. [pin_set](#pin_set)
   1. [pin_get](#pin_get)
   1. [pin_on_change](#pin_on_change)
   1. [internal_adc](#internal_adc)
   1. [pwm_configure_pair](#pwm_configure_pair)
   1. [pwm_set_value](#pwm_set_value)
   1. [stepper_init](#stepper_init)
   1. [stepper_status](#stepper_status)
   1. [stepper_move](#stepper_move)


## identify

Mostly for internal use: confirms the RP2DAQ device is up and has matching firmware version

__This command results in single near-immediate report.__

__Call signature:__

`identify(flush_buffer=1,  _callback=None)`

__Parameters__:

  * flush_buffer : Avoid possible pending messages from previous session 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pin_set

Changes the output state of the specified *pin*. The optional arguments, if not left default, determine the pin's
multi-state logic behaviour. Namely, if *high_z* = 1 and no "pulls" are set, the pin behaves as if 
disconnected (the impedance is over 1 megaohm). 

This still can be changed by setting *pull_up* or *pull_down*.

__This command results in single near-immediate report.__

__Call signature:__

`pin_set(pin, value, high_z=0, pull_up=0, pull_down=0,  _callback=None)`

__Parameters__:

  * pin : The number of the pin to be configured 
  * value : Output value (i.e. 0 or 3.3 V) for high_z 0 
  * high_z : High-impedance (i.e. not sinking nor sourcing current) 
  * pull_up : If high_z 1, connects to 3.3V through built-in resistor 
  * pull_down : If high_z 1, connects to 0V through built-in resistor 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pin_get

Checks the digital state of a pin. Most useful if the pin is configured as high-impedance input.

__This command results in single near-immediate report.__

__Call signature:__

`pin_get(pin,  _callback=None)`

__Parameters__:

  * pin   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pin_on_change

Sets up a pin to issue a report every time the pin changes its state. This is sensitive to both external and internal events.

__Fixme__: in current firmware, edge events cannot be turned off! 

__This command potentially results in multiple later reports. Note that input signal over 10kHz may result in some events not being reported.__

__Call signature:__

`pin_on_change(pin, on_rising_edge=1, on_falling_edge=1,  _callback=None)`

__Parameters__:

  * pin : Pin specification 
  * on_rising_edge : Reports on pin going from logical 0 to 1 
  * on_falling_edge : Reports on pin going from logical 1 to 0 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## internal_adc

Initiates analog-to-digital conversion (ADC), using the RP2040 built-in feature.

__This command can result in one, several or infinitely many report(s). They can be 
almost immediate or delayed, depending on block size and timing. __

__Call signature:__

`internal_adc(channel_mask=1, blocksize=1000, infinite=0, blocks_to_send=1, clkdiv=96,  _callback=None)`

__Parameters__:

  * channel_mask : Masks 0x01, 0x02, 0x04 are GPIO26, 27, 28; mask 0x08 internal reference, 0x10 temperature sensor 
  * blocksize : Number of sample points until a report is sent 
  * infinite : Disables blocks_to_send countdown (reports keep coming until explicitly stopped) 
  * blocks_to_send : Number of reports to be sent (if not infinite) 
  * clkdiv : Sampling rate is 48MHz/clkdiv (e.g. 96 gives 500 ksps; 48000 gives 1000 sps etc.) 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pwm_configure_pair

Sets frequency for a pair of pins ("slice")

To control usual small servos, set `wrap_value=65535, clkdiv=20` to get 190 Hz
cycle. Value of 10000 (0.8ms pulse) then turns servo near its minimum value,
and value of 30000 (2.4ms pulse) turns it near maximum value. YMMV.
(see https://en.wikipedia.org/wiki/Servo_control)

When PWM is smoothed to generate analog signal (like a poor man's DAC),
clkdiv=1 will yield best results; the wrap value can be reduced to get 
faster cycle, thus more efficient filtering & better time resolution.

Note while almost all GPIO pins can be enabled for PWM output, there are
only 16 channels (e.g. pins 0, 16 will have the same value, if PWM output 
enabled), and there are only 8 slices (e.g. pins 0, 1, 16 and 17 sharing 
also the same clkdiv, wrap and other config)

__This command results in one near-immediate report.__

__Call signature:__

`pwm_configure_pair(pin=0, wrap_value=999, clkdiv=1, clkdiv_int_frac=0,  _callback=None)`

__Parameters__:

  * pin   
  * wrap_value   
  * clkdiv   
  * clkdiv_int_frac   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pwm_set_value

Quickly sets duty cycle for one pin

It is assumed this pin already was configured by `pwm_configure_pair()`.

__This command results in one near-immediate report.__

__Call signature:__

`pwm_set_value(pin=0, value=0,  _callback=None)`

__Parameters__:

  * pin   
  * value   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_init



__Call signature:__

`stepper_init(stepper_number, dir_pin, step_pin, endswitch_pin=-1, disable_pin=-1, inertia=30,  _callback=None)`

__Parameters__:

  * stepper_number   
  * dir_pin   
  * step_pin   
  * endswitch_pin   
  * disable_pin   
  * inertia   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_status



__Call signature:__

`stepper_status(stepper_number,  _callback=None)`

__Parameters__:

  * stepper_number   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_move



__Call signature:__

`stepper_move(stepper_number, to, speed, endswitch_ignore=-1, endswitch_expect=-1, reset_nanopos=0,  _callback=None)`

__Parameters__:

  * stepper_number   
  * to   
  * speed   
  * endswitch_ignore   
  * endswitch_expect   
  * reset_nanopos   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 


