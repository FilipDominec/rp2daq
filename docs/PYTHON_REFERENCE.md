# RP2DAQ: Python API reference

This file was auto-generated by c_code_parser.py, using comments found in all ```include/*.c``` source files.

 If not specified otherwise, all data types are integers.

 Contents:

   1. [identify](#identify)
   1. [gpio_out](#gpio_out)
   1. [gpio_in](#gpio_in)
   1. [gpio_on_change](#gpio_on_change)
   1. [adc](#adc)
   1. [pwm_configure_pair](#pwm_configure_pair)
   1. [pwm_set_value](#pwm_set_value)
   1. [stepper_init](#stepper_init)
   1. [stepper_status](#stepper_status)
   1. [stepper_move](#stepper_move)
   1. [gpio_pull](#gpio_pull)
   1. [gpio_highz](#gpio_highz)
   1. [adc_stop](#adc_stop)


## identify

```Python
identify(flush_buffer=1,  _callback=None)```

Mostly for internal use: confirms the RP2DAQ device is up and has matching firmware version

__This command results in single near-immediate report.__

####Command parameters:

  * __ flush_buffer__  : Avoid possible pending messages from previous session  _(min=0, max=1, default=1)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 0 
  * __ _data_count__  
  * __ _data_bitwidth__  



## gpio_out

```Python
gpio_out(gpio, value,  _callback=None)```

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 
Depending on the "value=0" or "value=1" parameter, it connects the pin directly to 0 V,
or 3.3 V, respectively.  

This overrides previous high-impedance or pull-up/down state of the pin. 

__This command results in single, meaningless, near-immediate report.__

####Command parameters:

  * __ gpio__  : The number of the gpio to be configured  _(min=0, max=25)_ 
  * __ value__  : Output value (i.e. 0 or 3.3 V)  _(min=0, max=1)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 1  identifies command & report type 



## gpio_in

```Python
gpio_in(gpio,  _callback=None)```

Returns the digital state of a gpio pin. 

Typically used when the pin is set to high-z or pull-up/down.

> [!CAUTION]
> The maximum allowed voltage at any pin is 3.3V.

__This command results in single near-immediate report.__

####Command parameters:

  * __ gpio__  : _(min=0, max=25)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 2 
  * __ gpio__  
  * __ value__: 1 if pin connected to >2 V; 0 if connected to <1 V 



## gpio_on_change

```Python
gpio_on_change(gpio, on_rising_edge=1, on_falling_edge=1,  _callback=None)```

Sets up a gpio to issue a report every time the gpio changes its state. This is sensitive to both external and internal events.

__Fixme__: in current firmware, edge events cannot be turned off! 

__This command potentially results in multiple later reports. Note that input signal over 10kHz may result in some events not being reported.__

####Command parameters:

  * __ gpio__  : gpio specification  _(min=0, max=25)_ 
  * __ on_rising_edge__  : Reports on gpio going from logical 0 to 1  _(min=0, max=1, default=1)_ 
  * __ on_falling_edge__  : Reports on gpio going from logical 1 to 0  _(min=0, max=1, default=1)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 3 
  * __ gpio__  
  * __ events__  
  * __ time_us__  



## adc

```Python
adc(channel_mask=1, blocksize=1000, infinite=0, blocks_to_send=1, clkdiv=96, trigger_gpio=-1, trigger_on_falling_edge=0,  _callback=None)```

Initiates analog-to-digital conversion (ADC), using the RP2040 built-in feature.

When ADC is already active, this takes no action. Use adc_stop() first in such a case.  

__This command can result in one, several or infinitely many report(s). They can be 
almost immediate or delayed, depending on block size and timing.__

####Command parameters:

  * __ channel_mask__  : Bits 0x01, 0x02, 0x04 are GPIO26, 27, 28; mask 0x08 internal reference, 0x10 temperature sensor  _(min=1, max=31, default=1)_ 
  * __ blocksize__  : Number of sample points until a report is sent  _(min=1, max=8192, default=1000)_ 
  * __ infinite__  : Disables blocks_to_send countdown; reports will keep coming until stopped by adc(blocks_to_send=0)  _(min=0, max=1, default=0)_ 
  * __ blocks_to_send__  : Limits the number of reports to be sent (if the 'infinite' option is not set)  _(min=1, default=1)_ 
  * __ clkdiv__  : Sampling rate is 48MHz/clkdiv (e.g. 96 gives 500 ksps; 48000 gives 1000 sps etc.)  _(min=96, max=65535, default=96)_ 
  * __ trigger_gpio__  : GPIO number for start trigger (leave -1 to make ADC start immediately)  _(min=-1, max=24, default=-1)_ 
  * __ trigger_on_falling_edge__  : If set to 1, triggers on falling edge instead of rising edge.  _(min=0, max=1, default=0)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 4 
  * __ _data_count__  
  * __ _data_bitwidth__  
  * __ start_time_us__: Microsecond timestamp when ADC started this block acquisition. 
  * __ end_time_us__: Microsecond timestamp when ADC finished this block acquisition. 
  * __ start_sync_value__: Stepper[0] nanoposition when ADC started this block acquisition. (Will be configurable in future.) 
  * __ end_sync_value__: Stepper[0] nanoposition when ADC finished this block acquisition. (dtto) 
  * __ channel_mask__: The channel_mask value that was used (see adc() call parameters for details). 
  * __ blocks_to_send__: How many blocks remain to be sent. Does not change if adc set to infinite. 
  * __ block_delayed_by_usb__: Normally should be 0, except USB was overloaded and the ADC block had to wait for the USB buffer to accept new data. 



## pwm_configure_pair

```Python
pwm_configure_pair(gpio=0, wrap_value=999, clkdiv=1, clkdiv_int_frac=0,  _callback=None)```

Sets frequency for a "PWM slice", i.e. pair of GPIOs 

To control usual small servos, set `wrap_value=65535, clkdiv=20` to get 190 Hz
cycle. Value of 10000 (0.8ms pulse) then turns servo near its minimum value,
and value of 30000 (2.4ms pulse) turns it near maximum value. YMMV.
(see https://en.wikipedia.org/wiki/Servo_control)

When PWM is low-pass filtered to generate analog signal (like a poor man's DAC),
clkdiv=1 will yield best results; the wrap value can be reduced to get 
faster cycle, thus more efficient filtering & better time resolution.

Note while almost all GPIOs can be enabled for PWM output, there are
only 16 channels (e.g. GPIOs 0, 16 will have the same value, if PWM output 
enabled), and there are only 8 slices (e.g. GPIOs 0, 1, 16 and 17 share 
also the same clkdiv, wrap and clkdiv_int_frac values.)

__This command results in one near-immediate report.__

####Command parameters:

  * __ gpio__  : _(min=0, max=25, default=0)_ 
  * __ wrap_value__  : _(min=1, max=65535, default=999)_ 
  * __ clkdiv__  : _(min=1, max=255, default=1)_ 
  * __ clkdiv_int_frac__  : _(min=0, max=15, default=0)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 5 



## pwm_set_value

```Python
pwm_set_value(gpio=0, value=0,  _callback=None)```

Quickly sets duty cycle for one GPIO

It is assumed this GPIO already was configured by `pwm_configure_pair()`.

__This command results in one near-immediate report.__

####Command parameters:

  * __ gpio__  : _(min=0, max=25, default=0)_ 
  * __ value__  : _(min=0, max=65535, default=0)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 6 



## stepper_init

```Python
stepper_init(stepper_number, dir_gpio, step_gpio, endswitch_gpio=-1, disable_gpio=-1, inertia=30,  _callback=None)```

Rp2daq allows to control up to 16 independent stepper motors, provided that
each motor has its current driver compatible with Stepstick A4988. For this
driver rp2daq generates two control signals - "dir" and "step" - determining 
the direction and speed of rotation, respectively. The GPIO numbers of these
signals are mandatory parameters.

This command only defines constants and initializes the GPIO states, but does not 
move the stepper; see `stepper_move()` for getting it moving. 

> [!CAUTION]
> Never disconnect a stepper from Stepstick when powered. Interrupting the 
> current in its coils results in a voltage spike that may burn the driver chip.


####Command parameters:

  * __ stepper_number__  : The number of the stepper to be configured.  _(min=0, max=15)_ 
  * __ dir_gpio__  : Direction-controlling output GPIO pin.  _(min=0, max=24)_ 
  * __ step_gpio__  : Microstep-advancing output GPIO pin.  _(min=0, max=24)_ 
  * __ endswitch_gpio__  : GPIO that, once shorted to ground, can automatically stop the stepper whenever it reaches the minimum (or maximum) allowed position. The end stop switch is both safety and convenience measure, allowing one to easily calibrate the stepper position upon restart. More details are with the stepper_move() command.  _(min=-1, max=24, default=-1)_ 
  * __ disable_gpio__  : GPIO number that may be connected to the "!enable" pin on A4988 module - will automatically turn off current to save energy when the stepper is not moving. Note however it also loses its holding force.  _(min=-1, max=25, default=-1)_ 
  * __ inertia__  : Allows for smooth acc-/deceleration of the stepper, preventing it from losing steps at startup even at high rotation speeds. The default value is usually OK unless the stepper moves some heavy mass.  _(min=0, max=10000, default=30)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 7 
  * __ initial_nanopos__: This is the nanoposition the stepper was initialized to; always 0 in current firmware. 



## stepper_status

```Python
stepper_status(stepper_number,  _callback=None)```

Returns the position and endswitch status of the stepper selected by "stepper_number".

Additionally, returns three 16-bit integers (bitmasks) for all indices 0..15, 
describing if each corresponding stepper was initialized, if it is actively moving and 
if it is currently at endswitch. 

These bitmasks are particularly useful when multiple steppers are to be synchronized, 
e.g., into a two-dimensional movement. (New set of stepper_move() commands then would 
be issued only when all relevant bits in steppers_moving_bitmask are cleared.)

__Results in one immediate report.__

####Command parameters:

  * __ stepper_number__  : _(min=0, max=15)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 8 
  * __ timestamp_us__  
  * __ stepper_number__  
  * __ endswitch__  
  * __ nanopos__  
  * __ steppers_init_bitmask__  
  * __ steppers_moving_bitmask__  
  * __ steppers_endswitch_bitmask__  



## stepper_move

```Python
stepper_move(stepper_number, to, speed, endswitch_sensitive_up=0, endswitch_sensitive_down=1, relative=0, reset_nanopos_at_endswitch=0,  _callback=None)```

Starts stepping motor movement from current position towards the new position given by "to". The 
motor has to be initialized by stepper_init first (please refer to this command for more details on 
stepper control). 

> [!TIP]
> The units of position are nanosteps, i.e., 1/256 of a microstep. So typically if you have a motor
> with 200 steps per turn and your A4988-compatible driver is hard-wired for 16 microsteps/step, it takes 
> about a million (200x256x16 = 819200) nanosteps per turn.
>
> The "speed" is in nanosteps per 0.1 ms update cycle; thus setting speed=82 turns the motor in 
> the above example once in second. Setting minimal speed=1 gives 0.732 RPM. Note most stepper motors 
> won't be able to turn much faster than 600 RPM.

The "endswitch_sensitive_down" option is by default set to 1, i.e., the motor will immediately stop its 
movement towards more negative target positions when the end switch pin gets connected to zero. 

On the contrary, "endswitch_sensitive_up" is by default set to 0, i.e. the motor will move towards 
more positive target positions independent of the end switch pin.

Note: The defaults for the two above endswitch-related options assume you installed the endswitch at the 
lowest end of the stepper range. Upon reaching the endswitch, the stepper position is typically 
calibrated and it is straightforward to move upwards from the endswitch, without any change to the defaults.
Alternately, one can swap these two options if the endswitch is mounted on the highest end 
of the range. Or one can use different settings before/after the first calibration to allow the motor 
going beyond the end-switch(es) - if this is safe.

"reset_nanopos_at_endswitch" will reset the position if endswitch triggers the end of the 
movement. This is a convenience option for easy calibration of position using the endswitch. 
Note that the nanopos can also be manually reset by re-issuing the `stepper_init()` function. 

"relative" if set to true, rp2daq will add the `to` value to current nanopos; movement  
then becomes relative to the position of the motor when the command is issued. 

When no callback is provided, this command blocks your program until the movement is finished. 
Using asychronous commands one can easily make multiple steppers move at once.

The initial and terminal part of the movement are smoothly ac-/de-celerated, however issuing
this command to an already moving stepper results in its immediate stopping before it starts 
moving smoothly again.

__This command results one report after the movement is finished. Thus it may be immediate 
or delayed by seconds, minutes or hours, depending on distance and speed. __

####Command parameters:

  * __ stepper_number__  : _(min=0, max=15)_ 
  * __ to__ 
  * __ speed__  : _(min=1, max=10000)_ 
  * __ endswitch_sensitive_up__  : _(min=0, max=1, default=0)_ 
  * __ endswitch_sensitive_down__  : _(min=0, max=1, default=1)_ 
  * __ relative__  : _(min=0, max=1, default=0)_ 
  * __ reset_nanopos_at_endswitch__  : _(min=0, max=1, default=0)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 9 
  * __ stepper_number__  
  * __ nanopos__  
  * __ endswitch_was_sensitive__  
  * __ endswitch_triggered__  
  * __ steppers_init_bitmask__  
  * __ steppers_moving_bitmask__  
  * __ steppers_endswitch_bitmask__  
  * __ start_time_us__  
  * __ end_time_us__  



## gpio_pull

```Python
gpio_pull(gpio, value,  _callback=None)```

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 

Depending on the "pull=0" or "pull=1" parameter, it engages one of the built-in cca. 
50 kOhm resistors to pull the pin towards 0 or 3.3 V, respectively.  

This overrides previous direct-output or high-impedance state of the pin. 

__This command results in single, meaningless, near-immediate report.__

####Command parameters:

  * __ gpio__  : The number of the gpio to be configured  _(min=0, max=25)_ 
  * __ value__  : Output value (i.e. 0 or 3.3 V) for high_z 0  _(min=0, max=1)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 10  identifies command & report type 



## gpio_highz

```Python
gpio_highz(gpio,  _callback=None)```

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. 

The pin will become "high-impedance", or "floating", disconnected from any voltage 
supply or drain.

This overrides previous direct-output or pull-up/down state of the pin. 

__This command results in single, meaningless, near-immediate report.__

####Command parameters:

  * __ gpio__  : The number of the gpio to be configured  _(min=0, max=25)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 11  identifies command & report type 



## adc_stop

```Python
adc_stop(finish_last_adc_packet=1,  _callback=None)```

Manually sets the analog-to-digital conversion not to start another sampling ADC block after the active block is 
finished. Also an ADC block won't be started if it is waiting for a trigger event to start. 

Still, one or more ADC report(s) may still arrive after adc_stop() being issued; these were either actively 
sampled at the moment, or were stored in the USB transmit queue. 

Adc_stop() is most useful when adc(infinite=True) was previously called. Stopping ADC is also necessary to re-run 
it with different configuration. But if you want to sample exactly X blocks it may be easier to specify their number
by calling adc(blocks_to_send=X) instead.

If ADC is not running, this takes no action. 

__This command will result in one immediate report.  __

####Command parameters:

  * __ finish_last_adc_packet__  : Hard stopping of ADC in the middle of a block not implemented yet.  _(min=1, max=1, default=1)_ 
  * __ _callback __ : Optionally, a function to handle future report(s). If set, makes this command asynchronous so it does not wait for the command being finished. 


####Report returns:

  * __ report_code__: 12 
  * __ aborted_blocks_to_send__  

