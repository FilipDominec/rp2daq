# RP2DAQ: Python API reference

This file was auto-generated by c_code_parser.py, using comments found in all ```include/*.c``` source files.

 Contents:

   1. [identify](#identify)
   1. [gpio_out](#gpio_out)
   1. [gpio_in](#gpio_in)
   1. [gpio_on_change](#gpio_on_change)
   1. [adc](#adc)
   1. [pwm_configure_pair](#pwm_configure_pair)
   1. [pwm_set_value](#pwm_set_value)
   1. [stepper_init](#stepper_init)
   1. [stepper_status](#stepper_status)
   1. [stepper_move](#stepper_move)


## identify

Mostly for internal use: confirms the RP2DAQ device is up and has matching firmware version

__This command results in single near-immediate report.__

__Call signature:__

`identify(flush_buffer=1,  _callback=None)`

__Parameters__:

  * flush_buffer : Avoid possible pending messages from previous session 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## gpio_out

Changes the output state of the specified *gpio*, i.e. general-purpose input/output pin. The 
optional arguments, if not left default, determine the gpio's multi-state logic behaviour. 
Namely, if *high_z* = 1 and no "pulls" are set, the gpio behaves as if disconnected (the impedance 
is over 1 megaohm). 

This still can be changed by setting *pull_up* or *pull_down*.

__This command results in single near-immediate report.__

__Call signature:__

`gpio_out(gpio, value, high_z=0, pull_up=0, pull_down=0,  _callback=None)`

__Parameters__:

  * gpio : The number of the gpio to be configured 
  * value : Output value (i.e. 0 or 3.3 V) for high_z 0 
  * high_z : High-impedance (i.e. not sinking nor sourcing current, only through pull-up/-down if set) 
  * pull_up : If high_z 1, connects to 3.3V through built-in resistor 
  * pull_down : If high_z 1, connects to 0V through built-in resistor 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## gpio_in

Checks the digital state of a gpio. Most useful if the gpio is configured as high-impedance input.

__This command results in single near-immediate report.__

__Call signature:__

`gpio_in(gpio,  _callback=None)`

__Parameters__:

  * gpio   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## gpio_on_change

Sets up a gpio to issue a report every time the gpio changes its state. This is sensitive to both external and internal events.

__Fixme__: in current firmware, edge events cannot be turned off! 

__This command potentially results in multiple later reports. Note that input signal over 10kHz may result in some events not being reported.__

__Call signature:__

`gpio_on_change(gpio, on_rising_edge=1, on_falling_edge=1,  _callback=None)`

__Parameters__:

  * gpio : gpio specification 
  * on_rising_edge : Reports on gpio going from logical 0 to 1 
  * on_falling_edge : Reports on gpio going from logical 1 to 0 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## adc

Initiates analog-to-digital conversion (ADC), using the RP2040 built-in feature.

__This command can result in one, several or infinitely many report(s). They can be 
almost immediate or delayed, depending on block size and timing. __

__Call signature:__

`adc(channel_mask=1, blocksize=1000, infinite=0, blocks_to_send=1, clkdiv=96, trigger_gpio=-1, trigger_on_falling_edge=0,  _callback=None)`

__Parameters__:

  * channel_mask : Masks 0x01, 0x02, 0x04 are GPIO26, 27, 28; mask 0x08 internal reference, 0x10 temperature sensor 
  * blocksize : Number of sample points until a report is sent 
  * infinite : Disables blocks_to_send countdown (reports keep coming until explicitly stopped) 
  * blocks_to_send : Number of reports to be sent (if not infinite) 
  * clkdiv : Sampling rate is 48MHz/clkdiv (e.g. 96 gives 500 ksps; 48000 gives 1000 sps etc.) 
  * trigger_gpio : GPIO number for start trigger (set to -1 to make ADC start w/o trigger) 
  * trigger_on_falling_edge : If set to 1, triggers on falling edge instead of rising edge. 
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pwm_configure_pair

Sets frequency for a "PWM slice", i.e. pair of GPIOs 

To control usual small servos, set `wrap_value=65535, clkdiv=20` to get 190 Hz
cycle. Value of 10000 (0.8ms pulse) then turns servo near its minimum value,
and value of 30000 (2.4ms pulse) turns it near maximum value. YMMV.
(see https://en.wikipedia.org/wiki/Servo_control)

When PWM is low-pass filtered to generate analog signal (like a poor man's DAC),
clkdiv=1 will yield best results; the wrap value can be reduced to get 
faster cycle, thus more efficient filtering & better time resolution.

Note while almost all GPIOs can be enabled for PWM output, there are
only 16 channels (e.g. GPIOs 0, 16 will have the same value, if PWM output 
enabled), and there are only 8 slices (e.g. GPIOs 0, 1, 16 and 17 share 
also the same clkdiv, wrap and clkdiv_int_frac values.)

__This command results in one near-immediate report.__

__Call signature:__

`pwm_configure_pair(gpio=0, wrap_value=999, clkdiv=1, clkdiv_int_frac=0,  _callback=None)`

__Parameters__:

  * gpio   
  * wrap_value   
  * clkdiv   
  * clkdiv_int_frac   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## pwm_set_value

Quickly sets duty cycle for one GPIO

It is assumed this GPIO already was configured by `pwm_configure_pair()`.

__This command results in one near-immediate report.__

__Call signature:__

`pwm_set_value(gpio=0, value=0,  _callback=None)`

__Parameters__:

  * gpio   
  * value   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_init



__Call signature:__

`stepper_init(stepper_number, dir_gpio, step_gpio, endswitch_gpio=-1, disable_gpio=-1, inertia=30,  _callback=None)`

__Parameters__:

  * stepper_number   
  * dir_gpio   
  * step_gpio   
  * endswitch_gpio   
  * disable_gpio   
  * inertia   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_status



__Call signature:__

`stepper_status(stepper_number,  _callback=None)`

__Parameters__:

  * stepper_number   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 




## stepper_move



__Call signature:__

`stepper_move(stepper_number, to, speed, endswitch_ignore=-1, endswitch_expect=-1, reset_nanopos=0,  _callback=None)`

__Parameters__:

  * stepper_number   
  * to   
  * speed   
  * endswitch_ignore   
  * endswitch_expect   
  * reset_nanopos   
  * _callback : optional report handling function; if set, this command becomes asynchronous (does not wait for report) 


