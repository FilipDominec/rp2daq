// == APPROACH AND SCANNING STATE VARIABLES == {{{

uint8_t approach_active = 0;
uint8_t approach_stepper_number;    
int32_t approach_motor_targetpos;   
int32_t approach_motor_speed;       
int32_t approach_motor_cycle_steps; 
int16_t approach_piezo_speed;       

int16_t scan_x_start = 0;       
int16_t scan_x_end = 0;       
int16_t scan_x_speed = 0;       
int16_t scan_x_sampling_step = 100;       
int16_t scan_y_position = 0;       

uint8_t piezo_feedback_active = 0;
uint8_t piezo_scan_active = 0;

//#define SUBSAMPLE_BITS    8		//  TODO this is piezo control should allow for slower scanning than 1 LSB per cycle
#define ADC_THRESHOLD    1000	// feedback from the 12bit built-in ADC: full value of 4095 corresponds to ca. 3.3 V
/*}}}*/





/*
#define CMD_APPROACH 102	// safely approach the sample to the STM tip, using both stepper and piezo{{{
struct cmd_approach_struct  {  
    uint8_t message_type;                
    uint8_t stepper_number;    // at byte 1
    int32_t motor_targetpos;   // at byte 2
    int32_t motor_speed;       // at byte 6
    int32_t motor_cycle_steps; // at byte 10
    int16_t piezo_speed;       // at byte 14
} __attribute__((packed)); 
#define CMD_GET_STM_STATUS 104		// just report the current nanopos and status
struct cmd_get_stm_status_struct  {  
    uint8_t message_type;                
    // todo
} __attribute__((packed)); 
#define CMD_SET_PIEZO  109		// set a concrete position on the piezo
struct cmd_set_piezo_struct  {  
    uint8_t message_type;      // always byte 0
    int16_t piezo_x;			   // at byte 1			(note that full uint32 range may not be used by the dac)
    int16_t piezo_y;			   // at byte 5			
    int16_t piezo_z;			   // at byte 9		
} __attribute__((packed));
#define CMD_LINESCAN 110
struct cmd_linescan_struct  {  // todo
    uint8_t message_type;                
    int16_t scan_x_start;			   // at byte  1
    int16_t scan_x_end;                // at byte  5
    int16_t scan_x_speed;              // at byte  9
    int16_t scan_x_sampling_step;      // at byte 13
    int16_t scan_y_position;           // at byte 17
} __attribute__((packed)); 
*/




#define HARD_LIMIT_LOW  -(1<<(DACBITS-1))						// "Hard" limits prevent DAC over- and under- flows. Should never be exceeded.
#define HARD_LIMIT_HIGH (1<<(DACBITS-1))	
#define HARD_LIMIT_CENTRE (HARD_LIMIT_LOW+HARD_LIMIT_HIGH)/2
#define HARD_LIMIT_EXTENT (HARD_LIMIT_HIGH-HARD_LIMIT_LOW)
#define SOFT_LIMIT_LOW    (HARD_LIMIT_CENTRE-HARD_LIMIT_EXTENT/6+1)  // "Soft" limits prevent STM range clipping during Cartesian-quadrant conv.
#define SOFT_LIMIT_HIGH   (HARD_LIMIT_CENTRE+HARD_LIMIT_EXTENT/6-1)  // Note: if e.g. x=y=0, the z coord can go up to hard limits without trouble
int16_t x = 0;		// Cartesian coords will be linearly combined for the four-quadrant piezo transducer
int16_t y = 0;
int16_t z = 0;

// Piezo controlling pseudo-constants
#define ADC_PIN          4				// input from the ADC





void set_piezo_slow(int16_t target_x, int16_t target_y, int16_t target_z, int16_t speed_limit) { 
    while ((x!=target_x) || (y!=target_y) || (z!= target_z)) { 
        if (speed_limit == 0) { 
            x=target_x; y=target_y; z= target_z; 
        } else {
            if (x > target_x) {x = max(target_x, x-speed_limit);}
            if (x < target_x) {x = min(target_x, x+speed_limit);}

            if (y > target_y) {y = max(target_y, y-speed_limit);}
            if (y < target_y) {y = min(target_y, y+speed_limit);}

            if (z > target_z) {z = max(target_z, z-speed_limit);}
            if (z < target_z) {z = min(target_z, z+speed_limit);}
            sleep_us(100); 
        }

        set_piezo_raw(+ x + y + z,
                - x + y + z,
                - x - y + z,
                + x - y + z); 
    }				 
}




    } else if ((in_buf[0] == CMD_APPROACH) && (in_buf_ptr == sizeof(cmd_approach_struct))) {
        set_piezo_slow(0,0,SOFT_LIMIT_LOW, 100); // fast retract piezo to centre top 

        approach_stepper_number     = *((uint8_t*)(in_buf+ 1)); // at byte 1
        approach_motor_targetpos    = *((int32_t*)(in_buf+ 2)); // at byte 2
        approach_motor_speed        = *((int32_t*)(in_buf+ 6)); // at byte 6
        approach_motor_cycle_steps  = *((int32_t*)(in_buf+10)); // at byte 10
        approach_piezo_speed        = *((int16_t*)(in_buf+14)); // at byte 14

        piezo_feedback_active = 0;
        piezo_scan_active = 0;
        approach_active  = 1;

        in_buf_ptr = 0;
    } else if ((in_buf[0] == CMD_GET_STM_STATUS) && (in_buf_ptr == sizeof(cmd_get_stm_status_struct))) {
        I adcvalue = 0;
        for(int16_t j=0; j<16; j++) {
            adcvalue += analogRead(ADC_PIN);
        }

        for(out_buf_ptr=0; out_buf_ptr<OUT_BUF_LEN; out_buf_ptr+=2) { // todo: OUT_BUF_LEN/2
            adcvalue = analogRead(ADC_PIN);;		
            //out_buf[out_buf_ptr*2] 
            memcpy(out_buf+out_buf_ptr, &adcvalue, 2);
        };
        for (out_buf_ptr=0; out_buf_ptr<OUT_BUF_LEN;  out_buf_ptr++)  { Serial.write(out_buf[out_buf_ptr]); } // todo use transm...
        //transmit_out_buf(12);
        //for (int16_t j=0; j<scan_data_ptr; j++) { Serial.write(123); }
        //for (int16_t j=0; j<scan_data_ptr; j++) { Serial.write(scan_data[j]); }
        scan_data_ptr = 0;
        in_buf_ptr = 0;
    } else if ((in_buf[0] == CMD_SET_PIEZO) && (in_buf_ptr == sizeof(cmd_set_piezo_struct))) {
        //set_piezo_slow(*((int16_t*)(in_buf+ 2)), *((int16_t*)(in_buf+ 4)), *((int16_t*)(in_buf+ 8)), 100); 
        in_buf_ptr = 0;
        set_piezo_slow(x, y, SOFT_LIMIT_LOW, 100); 
        set_piezo_slow(*((int16_t*)(in_buf+ 1)), *((int16_t*)(in_buf+ 3)), SOFT_LIMIT_LOW, 100); 
    } else if ((in_buf[0] == CMD_LINESCAN) && (in_buf_ptr == sizeof(cmd_linescan_struct))) {
        scan_x_start		= *((int16_t*)(in_buf+ 1)); 
        scan_x_end        = *((int16_t*)(in_buf+ 3));
        scan_x_speed      = *((int16_t*)(in_buf+ 5));
        scan_x_sampling_step  = *((int16_t*)(in_buf+7));
        scan_y_position = *((int16_t*)(in_buf+9)); 

        // safely go to the initial piezo position and enable scanning (in the main routine)
        piezo_feedback_active = 1;
        piezo_scan_active = 1;

        in_buf_ptr = 0;

        //out_buf[0] = x;
        //out_buf[1] = y;
        //for (out_buf_ptr=0; out_buf_ptr<5; out_buf_ptr++) {
        //Serial.write(out_buf[out_buf_ptr]);
        //}
        //target_nanopos[0] = *((uint32_t*)(buffer+1));     // how to receive an uint32
        //uint32_t tmp =  42*256*256+256+123;				// how to send an uint32
        //memcpy(out_buf+out_buf_ptr, &tmp, sizeof(tmp)); out_buf_ptr += sizeof(tmp);





